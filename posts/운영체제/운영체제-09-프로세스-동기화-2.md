# [운영체제] Process Synchronization #2

## Semaphores

![Semaphores](../../assets/img/posts/운영체제/09-01.png)

예를 들어 S = 5라고 하면 5번의 P 연산이 가능하고, 그 이후 V 연산을 수행해야 P 연산이 가능하다.

![Semaphores 2](../../assets/img/posts/운영체제/09-02.png)


## Block / Wakeup Implementation

-  Semaphore를 아래와 같이 정의

```
typedef struct {
    int value; // semaphore
    struct process *L; // process wait queue
} semaphore;
```

- block과 wakeup을 다음과 같이 가정
- block: 커널은 block을 호출한 프로세스를 suspend시킴. 이 프로세스의 PCB를 semaphore에 대한 wait queue에 넣음.
- wakeup(P): block된 프로세스 P를 wakeup 시킴. 이 프로세스의 PCB를 ready queue로 옮김.

- Semaphore 연산이 이제 다음과 같이 정의됨

![](../../assets/img/posts/운영체제/09-03.png)

## Busy-wait vs Block/wakeup

- critical section의 길이가 긴 경우 block/wakeup이 적당
- critical section의 길이가 매우 짧은 경우 busy-wait이 적당
- 일반적으로 block/wakeup이 더 좋음

## Two Types of Semaphores

- Counting semaphore
    - 도메인이 0 이상인 임의의 정수값
    - 주로 resource counting에 사용
- Binary semaphore
    - 0 또는 1 값만 가질 수 있는 semaphore
    - 주로 mutual exclusion (lock/unlock)에 사용

## Deadlock and Starvation

- Deadlock
    - 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 event를 무한히 기다리는 현상

![](../../assets/img/posts/운영체제/09-04.png)

-> 자원을 얻는 순서를 동일하게 하면 해결 가능. 위 예에서 P1 프로세스가 P1 프로세스와 같이 S, Q 자원을 순서대로 요구하면 해결 가능.

- Starvation
    - indefinite blocking. 프로세스가 suspend된 이유에 해당하는 semaphore queue에 빠져나갈 수 없는 현상

